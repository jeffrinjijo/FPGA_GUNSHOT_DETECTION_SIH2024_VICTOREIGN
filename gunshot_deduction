import os
import random
import librosa
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, lfilter, correlate

# Constants
DATASET_DIR = '/Users/jeffrinjijo/Desktop/gunshotsamples'
SAMPLE_RATE = 1e4  # 10 kHz sampling rate
BIT_DEPTH = 14  # ADC resolution
CUT_OFF_FREQUENCY = 2900  # Hz
FILTER_ORDER = 8
ADC_RESOLUTION = 2**BIT_DEPTH - 1
GAIN = 0.01  # Convert mV to V

# Microphone positions in a hexagonal array (x, y)
MIC_POSITIONS = np.array([
    [0, 0],                      # Mic 1: Center
    [1, 0],                      # Mic 2: Right
    [0.5, np.sqrt(3)/2],         # Mic 3: Top-right
    [-0.5, np.sqrt(3)/2],        # Mic 4: Top-left
    [-1, 0],                     # Mic 5: Left
    [-0.5, -np.sqrt(3)/2],       # Mic 6: Bottom-left
    [0.5, -np.sqrt(3)/2]         # Mic 7: Bottom-right
])

# Butterworth Filter
def butter_lowpass_filter(data, cutoff, fs, order=FILTER_ORDER):
    nyquist = 0.5 * fs
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return lfilter(b, a, data)

# Load Random Gunshot Audio
def load_random_gunshot_audio():
    audio_files = [f for f in os.listdir(DATASET_DIR) if f.endswith('.wav')]
    if not audio_files:
        print("No audio files found!")
        return None, None, None
    filename = random.choice(audio_files)
    print(f"Loading Gunshot Audio: {filename}")
    y, sr = librosa.load(os.path.join(DATASET_DIR, filename), sr=int(SAMPLE_RATE))
    return y, sr, filename

# ADC Conversion
def adc_conversion(filtered_signal):
    centered_signal = (filtered_signal - np.min(filtered_signal)) / (np.max(filtered_signal) - np.min(filtered_signal))
    digital_signal = np.round(centered_signal * ADC_RESOLUTION).astype(int)
    return digital_signal

# TDOA Calculation
def calculate_tdoa(signals):
    ref_signal = signals[0]
    tdoas = []
    for sig in signals[1:]:
        corr = correlate(ref_signal, sig, mode='full')
        delay = np.argmax(corr) - len(ref_signal) + 1
        tdoas.append(delay / SAMPLE_RATE)
    return np.array(tdoas)

# Estimate Direction from TDOA
def estimate_direction(tdoas):
    # Use the first 5 microphone positions to match the tdoas shape
    relevant_positions = MIC_POSITIONS[1:6]  # Select Mic 2 to Mic 6 (5 positions)
    
    estimated_pos = np.sum(relevant_positions * tdoas[:, None], axis=0)
    normalized_pos = estimated_pos / np.max(np.abs(tdoas))
    
    angle = np.degrees(np.arctan2(normalized_pos[1], normalized_pos[0]))
    latitude = 30 + normalized_pos[1]
    longitude = 50 + normalized_pos[0]
    
    return normalized_pos, angle, latitude, longitude


# Updated Beamforming and Triangulation
def plot_beamforming_and_triangulation(tdoas, estimated_pos):
    angles = np.linspace(0, 360, 360)
    random_offsets = np.random.uniform(-5, 5, size=angles.shape)
    perturbed_tdoas = tdoas.mean() + random_offsets / 1000
    beamforming_output = np.cos(np.radians(angles - np.degrees(perturbed_tdoas)))
    beamforming_output = (beamforming_output - beamforming_output.min()) / (beamforming_output.max() - beamforming_output.min())
    
    plt.subplot(1, 2, 1)
    for mic_pos in MIC_POSITIONS:
        plt.scatter(*mic_pos, c='b', s=100)
    plt.scatter(estimated_pos[0], estimated_pos[1], c='r', label="Estimated Source", marker='x')
    plt.title("Triangulation Plot")
    plt.xlabel("X Position")
    plt.ylabel("Y Position")
    plt.legend()
    plt.grid(True)

    plt.subplot(1, 2, 2)
    plt.plot(angles, beamforming_output, 'r')
    plt.title("Beamforming Pattern")
    plt.xlabel("Angle (degrees)")
    plt.ylabel("Signal Amplification")
    plt.grid(True)

# Run Simulation
def run_simulation():
    analog_signal, sr, filename = load_random_gunshot_audio()
    if analog_signal is None:
        return

    t = np.linspace(0, len(analog_signal) / sr, len(analog_signal))
    analog_signal_volts = analog_signal * GAIN
    filtered_signal = butter_lowpass_filter(analog_signal_volts, CUT_OFF_FREQUENCY, SAMPLE_RATE)
    digital_signal = adc_conversion(filtered_signal)
    signals = [np.roll(digital_signal, random.randint(0, 100)) for _ in range(6)]
    tdoas = calculate_tdoa(signals)
    position, angle, latitude, longitude = estimate_direction(tdoas)

    first_mic = np.argmin(np.abs(tdoas))
    detection_times = tdoas * 1e6  # in microseconds

    print("\n--- TDOA Values ---")
    for i, tdoa in enumerate(tdoas):
        print(f"Mic {i+1} TDOA: {tdoa:.6f} s ({detection_times[i]:.2f} μs)")

    print(f"\nGunshot detected first by Mic {first_mic+1}.")
    print(f"Estimated Position: X={position[0]:.2f}, Y={position[1]:.2f}")
    print(f"Direction Angle: {angle:.2f}°")
    print(f"Latitude: {latitude:.2f}, Longitude: {longitude:.2f}")

    plt.figure(figsize=(15, 12))

    plt.subplot(4, 1, 1)
    plt.plot(t, analog_signal_volts, 'b')
    plt.title("Analog Signal with Noise")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude (V)")

    plt.subplot(4, 1, 2)
    plt.plot(t, filtered_signal, 'g')
    plt.title("Filtered Gunshot Signal")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude (V)")

    plt.subplot(4, 1, 3)
    plt.plot(t, analog_signal_volts, label="Analog", alpha=0.6)
    plt.plot(t, filtered_signal, label="Filtered", alpha=0.8)
    plt.title("Comparison: Analog vs. Filtered Signal")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude (V)")
    plt.legend()

    plt.subplot(4, 1, 4)
    plt.stem(t, digital_signal / ADC_RESOLUTION, linefmt='r-', markerfmt='ro', basefmt=' ')
    plt.title("Digital Signal (ADC Output)")
    plt.xlabel("Time (s)")
    plt.ylabel("Normalized Amplitude")

    plt.tight_layout()
    plt.show()

    plt.figure(figsize=(15, 6))
    plot_beamforming_and_triangulation(tdoas, position)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    run_simulation()
